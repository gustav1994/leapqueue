<?php

namespace LeapQueue;

use PDO;
use Exception;
use LeapQueue\Job;
use LeapQueue\QueueGroup;
use LeapQueue\Interfaces\CanMigrateInterface;
use LeapQueue\Interfaces\PullStrategyInterface;
use LeapQueue\Traits\DatabaseTrait;
use LeapQueue\Traits\FactoryTrait;
use LeapQueue\Traits\OrmTrait;

class Queue implements CanMigrateInterface
{    
    use DatabaseTrait, FactoryTrait, OrmTrait;

    protected static $tableName = 'queues';

    /**
     * Fields that can be updated or inserted (not generated by database)
     * @var array
     */
    protected $mutableFields = ['code'];   
    
    /**
     * Using a strategy take out jobs from the queue in a transaction that..
     *   1. Select and lock job FOR UPDATE SKIP LOCKED
     *   2. Update available_at into the future
     * 
     * 
     * 
     * @param PullStrategyInterface $strategy
     * @return array Array of jobs
     */
    public function pull( PullStrategyInterface $strategy ) : array
    {
        self::$db->beginTransaction();

        $sql = "
            SELECT *
            FROM " . Job::getTableName() . "
            WHERE queue_id = :queue_id AND available_at <= NOW()            
            LIMIT 5000
            FOR UPDATE SKIP LOCKED
        ";
        $stmt = static::$db->prepare($sql);
        $stmt->setFetchMode(PDO::FETCH_CLASS, Job::class);        
        $stmt->execute([':queue_id' => $this->fields['id']]);

        $jobs = $stmt->fetchAll();
        $jobIds = array_map(fn($job) => (int) $job->id, $jobs);

        // Now update and put into the future        
        $sql = "
            UPDATE " . Job::getTableName() . "
            SET available_at = NOW() + INTERVAL 15 MINUTE
            WHERE id IN (". implode(',', array_fill(0, count($jobIds), '?')) . ")
        ";
        $stmt = static::$db->prepare($sql);
        $stmt->execute($jobIds);

        static::$db->commit();

        return $jobs;
    }

    /**
     * Push a single job into the queue. If the group code is not provided
     * we generate a random group code for the job. We distribute this "velocity" queue group id
     * over 1.000 random integers to minimize the risk of collisions and to ensure a more
     * even distribution of jobs across groups.
     * 
     * @param Job $job
     * @param string|null $groupCode
     * @return bool
     */
    public function push( Job $job, ?string $groupCode = null ) : bool
    {
        if( isset($job->id) ) {
            throw new Exception('Cannot push a job that is already persisted. Job ID: ' . $job->id);
        }

        $finalGroupCode = $groupCode ?? 'velocity_group_' . random_int(1, 1000);

        $queueGroup = $this->findOrCreateQueueGroup($finalGroupCode);

        // Now we can persist the job into the queue and the group
        $job->queue_id = $this->id;
        $job->group_id = $queueGroup->id;
        $job->job = serialize($job->job);
                
        return $job->save();
    }

    /**
     * Check if we have a queue group with the provided code, if not we create it and return
     * the instance of the group.
     * 
     * @param string $code
     * @return QueueGroup
     */
    protected function findOrCreateQueueGroup( string $code ) : QueueGroup
    {
        $group = QueueGroup::find([
            'queue_id' => $this->fields['id'],
            'code' => $code
        ]);

        if( !$group ) {

            $group = new QueueGroup();
            $group->queue_id = (int) $this->fields['id'];
            $group->code = $code;

            $group->save();
        }

        return $group;
    }

    /**     
     * See documentation of the setConnection method in the DatabaseTrait.
     * 
     * @param array $config
     * @param PDO $db     
     * @return void
     */
    public static function boot( array $config, ?PDO $db = null ) : void
    {
        $dbConfig = $config['database'] ?? [];

        static::setConnection($dbConfig, $db);
        QueueGroup::setConnection($dbConfig, static::$db);
        Job::setConnection($dbConfig, static::$db);
    }

    public static function migrateAll()
    {
        return self::migrateOrDownAll('migrate');
    }  

    public static function downAll()
    {
        return self::migrateOrDownAll('down');
    }
    
    protected static function migrateOrDownAll( string $method ) : bool
    {
        if( !in_array($method, ['migrate', 'down']) ) {
            throw new \InvalidArgumentException('Method must be either migrate or down');
        }

        $migrationClasses = [
            self::class,
            QueueGroup::class,
            Job::class
        ];

        // Count number of successful actions against the database
        $successes = 0;

        foreach( $migrationClasses as $class ) {
            
            $interfaces = class_implements($class);

            if( in_array(CanMigrateInterface::class, $interfaces) ) {
                $successes += $method === 'down' ? $class::down() : $class::migrate();
            }

        }
        
        return count($migrationClasses) === $successes;
    }

    public static function migrate() : bool
    {
        $sql = "
            CREATE TABLE IF NOT EXISTS ". static::getTableName() ." (    
                -- Column Definitions
                id SMALLINT UNSIGNED AUTO_INCREMENT,
                code VARCHAR(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
                created_at TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6),    
                
                -- Indexes
                PRIMARY KEY (id),
                UNIQUE INDEX idx_unique_code (code)
            ) ENGINE=InnoDb COMMENT='Table created and managed by LeapQueue'
        ";
        return static::$db->exec($sql);
    }

    public static function down() : bool
    {        
        static::$db->exec("SET FOREIGN_KEY_CHECKS = 0");        
        $result = static::$db->exec("DROP TABLE IF EXISTS " . static::getTableName());
        static::$db->exec("SET FOREIGN_KEY_CHECKS = 1");

        return $result;
    }

}
