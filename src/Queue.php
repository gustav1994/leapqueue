<?php

namespace LeapQueue;

use PDO;
use Exception;
use LeapQueue\Job;
use LeapQueue\QueueGroup;
use LeapQueue\Interfaces\CanMigrateInterface;
use LeapQueue\Interfaces\PullStrategyInterface;
use LeapQueue\Traits\DatabaseTrait;
use LeapQueue\Traits\FactoryTrait;
use LeapQueue\Traits\OrmTrait;

class Queue implements CanMigrateInterface
{    
    use DatabaseTrait, FactoryTrait, OrmTrait;

    protected static $tableName = 'queues';

    /**
     * Fields that can be updated or inserted (not generated by database)
     * @var array
     */
    protected $mutableFields = ['code'];   
    
    /**
     * Using a strategy take out jobs from the queue in a transaction that..
     *   1. Select and lock job FOR UPDATE SKIP LOCKED
     *   2. Update available_at into the future
     
     * @param PullStrategyInterface $strategy
     * @param int $visibilityTimeout
     * @return array Array of jobs
     */
    public function pull( PullStrategyInterface $strategy, int $visibilityTimeout = 900 ) : array
    {
        $strategyCriteria = $strategy->selectionCriteria($this);
            
        // Search conditions and bindings is a combination of the basic criteria
        // and what is provided by the strategy of choice.
        $conditions = array_merge(['job.queue_id = :queue_id', 'job.available_at <= NOW()'], $strategyCriteria['where'] ?? '');
        $bindings = array_merge([':queue_id' => $this->id], $strategyCriteria['bindings'] ?? []);

        // Run the extract and the locking in a transaction, so if we cannot lock the rows for some reason we rollback as well.
        self::$db->beginTransaction();

        try {        
            // Construct the final Query from the information we got from the pull strategy. 
            // @todo figure out what PDO drivers support "FOR UPDATE SKIP LOCKED".            
            $sql = "
                SELECT job.*
                FROM " . Job::getTableName() . " AS job
                WHERE ". implode(' AND ', $conditions) ."
                ORDER BY ". $strategy->getOrderBySql() . "
                LIMIT 0, ". $strategy->getMaxJobs() ."
                FOR UPDATE SKIP LOCKED
            ";
            $stmt = static::$db->prepare($sql);            
            $stmt->setFetchMode(PDO::FETCH_CLASS, Job::class); 
            $stmt->execute($bindings);

            $allJobs = $stmt->fetchAll();
            
            // Check if the strategy wants to filter the jobs before we lock them
            $filteredJobs = $strategy->filterJobs($allJobs);
            $filteredJobIds = array_map(fn($job) => (int) $job->id, $filteredJobs);

            // Now we lock the rows by setting the availability into the future. As long as 
            // available_at is mroe than current timestamp they cannot be extracted (see above SELECT)    
            $sql = "
                UPDATE " . Job::getTableName() . "
                SET available_at = NOW() + INTERVAL {$visibilityTimeout} SECOND
                WHERE id IN (". implode(',', array_fill(0, count($filteredJobIds), '?')) . ")
            ";
            $stmt = static::$db->prepare($sql);
            $stmt->execute($filteredJobIds);            

            self::$db->commit();

        } catch( Exception $e ) {
            
            self::$db->rollBack();            
            throw $e;

        }

        return $filteredJobs;
    }

    /**
     * Push a single job into the queue. If the group code is not provided
     * we generate a random group code for the job. We distribute this "velocity" queue group id
     * over 1.000 random integers to minimize the risk of collisions and to ensure a more
     * even distribution of jobs across groups.
     * 
     * @todo change this to accept batch of jobs and make batch inserts with 1000 rows in each batch.
     * @todo consider moving the groupCode to the Job model
     * 
     * @param Job $job
     * @param string|null $groupCode
     * @return bool
     */
    public function push( Job $job, ?string $groupCode = null ) : bool
    {
        if( isset($job->id) ) {
            throw new Exception('Cannot push a job that is already persisted. Job ID: ' . $job->id);
        }

        $finalGroupCode = $groupCode ?? 'velocity_group_' . random_int(1, 1000);

        $queueGroup = $this->findOrCreateQueueGroup($finalGroupCode);

        // Now we can persist the job into the queue and the group
        $job->queue_id = $this->id;
        $job->group_id = $queueGroup->id;
        $job->job = serialize($job->job);
                
        return $job->save();
    }

    /**
     * Check if we have a queue group with the provided code, if not we create it and return
     * the instance of the group.
     * 
     * @param string $code
     * @return QueueGroup
     */
    protected function findOrCreateQueueGroup( string $code ) : QueueGroup
    {
        $group = QueueGroup::find([
            'queue_id' => (int) $this->id,
            'code' => $code
        ]);

        if( !$group ) {

            $group = new QueueGroup();
            $group->queue_id = (int) $this->fields['id'];
            $group->code = $code;

            $group->save();
        }

        return $group;
    }

    /**     
     * See documentation of the setConnection method in the DatabaseTrait.
     * 
     * @param array $config
     * @param PDO $db     
     * @return void
     */
    public static function boot( array $config, ?PDO $db = null ) : void
    {
        $dbConfig = $config['database'] ?? [];

        // If we cannot set the connection on ourselves, then it will most properly
        // also throw exceptions in the QueueGroup and Job classes.
        try {
            static::setConnection($dbConfig, $db);
        } catch( Exception $e ) {
            throw new Exception('Failed to boot LeapQueue: ' . $e->getMessage());
        }
        
        QueueGroup::setConnection($dbConfig, static::$db);
        Job::setConnection($dbConfig, static::$db);
    }

    public static function migrateAll()
    {
        return self::migrateOrDownAll('migrate');
    }  

    public static function downAll()
    {
        return self::migrateOrDownAll('down');
    }
    
    protected static function migrateOrDownAll( string $method ) : bool
    {
        if( !in_array($method, ['migrate', 'down']) ) {
            throw new \InvalidArgumentException('Method must be either migrate or down');
        }

        $migrationClasses = [
            self::class,
            QueueGroup::class,
            Job::class
        ];

        // Count number of successful actions against the database
        $successes = 0;

        foreach( $migrationClasses as $class ) {
            
            $interfaces = class_implements($class);

            if( in_array(CanMigrateInterface::class, $interfaces) ) {
                $successes += $method === 'down' ? $class::down() : $class::migrate();
            }

        }
        
        return count($migrationClasses) === $successes;
    }

    public static function migrate() : bool
    {
        $sql = "
            CREATE TABLE IF NOT EXISTS ". static::getTableName() ." (    
                -- Column Definitions
                id SMALLINT UNSIGNED AUTO_INCREMENT,
                code VARCHAR(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
                created_at TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6),    
                
                -- Indexes
                PRIMARY KEY (id),
                UNIQUE INDEX idx_unique_code (code)
            ) ENGINE=InnoDb COMMENT='Table created and managed by LeapQueue'
        ";
        return static::$db->exec($sql);
    }

    public static function down() : bool
    {        
        static::$db->exec("SET FOREIGN_KEY_CHECKS = 0");        
        $result = static::$db->exec("DROP TABLE IF EXISTS " . static::getTableName());
        static::$db->exec("SET FOREIGN_KEY_CHECKS = 1");

        return $result;
    }

}
